# Linux C语言指针与内存

## 一、初始指针
```
#include <stdio.h>
  
void change (int a,int b)
{
    int tmp = a;
    a = b;
    b = tmp;
}

int main()
{
    int a = 5;
    int b = 3;
    change(a,b);
    printf("num a = %d\nnum b = %d\n",a,b);
}

```
经典问题,输出后,a为什么依然是5,b是3?
```
#include <stdio.h>

void change (int *a,int *b)
{
    int tmp = *a;
    *a = *b;
    *b = tmp;

}

int main()
{
    int a = 5;
    int b = 3;
    change(&a,&b);
    printf("num a = %d\nnum b = %d\n",a,b);

```
​		方法内的变量存在定义域,简单来说就是出了方法就不认识.在main方法中的ab变量和change方法中的变量ab是完全不同的变量,change方法中两个数值交换和main方法数值无关.
​	
​		为什么就可以改变?
首先要了解概念:
​		** *+变量名 ** 为全新的类型变量指针类型
​		** &+变量名 ** &为取地址符 取出变量的地址,以16进制表达.
​		如果一个函数接收的是指针类型 ,则传递的参数需要带有取地址符.
​		main调用change方法时传递过去的参数为16进制的内存地址,change收到*a和*b两个参数,分别表示a和b的指针,指针指向内存地址.然后tmp得到*a指针指向的地址中的内容(*a=5),b指针的内存地址中的值(3)赋值a指针内存地址,tmp再把值交给b指针,完成两个数的交换后返回main方法ab变量内存地址没变,但是里面的值发生了改变.

## 二、gdb工具的使用.
​		使用`gcc -g xxx.c`的方式可以将.c文件编译为可调试.
​		通过gdb工作我们可以通过每一步的流程了解变量的动态变化.		

​	    > 命令：

​			list：显示当前源代码

​			start：开始调试

​			P+变量名 ：变量的值

​			n: 单步跳过   s: 单步进入

​			回车：执行上步命令			

​			break:打断点	

​			bt: 查看函数堆栈

​			f+编号:跳转函数

### 三、指针与内存
** 注:加不加星号都是指针 设指针p  输出p则为地址,输出*p则为地址中的值 **

#### 计算机数据表示方法
由于二进制会写的很麻烦,所以计算机中引用了16进制
#### 内存管理
![avatar](https://img-blog.csdn.net/20180823001107829?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxMDM1NTg4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)



内存简单分区

栈内存:存储运行的程序,当前的状态.,自动分配,速度快.自由可分配内存.

堆内存:程序员手动new开辟,手动释放,最方便.

数据段:全局变量,常量放在数据段.

代码段:代码编译后存到磁盘,运行时这些指令放在代码段也是最低位内存.

#### 变量和指针的本质

变量的本质是内存.CPU从内存中取数据,它要知道从那个内存单元中取,变量就是告诉cpu从哪里去取数据,或者把数据写到什么地方去.定义变量,就是在内存中申请一块区域放值.

指针本质是内存的地址.

